{"version":3,"sources":["Movie.js","App.js","index.js"],"names":["Movie","title","year","rating","genres","synopsis","poster","classsname","clssssname","src","alt","map","genre","index","prototype","id","PropTypes","number","isRequired","string","arrayOf","App","state","isLoading","movies","getMovies","a","axios","get","data","setState","this","movie","medium_cover_image","React","Component","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"mSAIA,SAASA,EAAT,GAA2D,IAA3CC,EAA0C,EAA1CA,MAAMC,EAAoC,EAApCA,KAAKC,EAA+B,EAA/BA,OAAOC,EAAwB,EAAxBA,OAAOC,EAAiB,EAAjBA,SAASC,EAAQ,EAARA,OAC9C,OACI,sBAAKC,WAAW,QAAhB,UACI,sBAAKA,WAAW,mBAAhB,UACI,oBAAIA,WAAW,cAAf,SAA8BN,IAC9B,oBAAIO,WAAW,aAAf,SAA6BN,OAEjC,qBAAKK,WAAW,eAAhB,SACI,qBAAKE,IAAKH,EAAQI,IAAKT,EAAOA,MAAOA,MAEzC,oBAAIM,WAAW,eAAf,SACKH,EAAOO,KAAI,SAACC,EAAMC,GAAP,OACR,oBAAgBN,WAAW,qBAA3B,SAAiDK,GAAxCC,QAGjB,mBAAGN,WAAW,gBAAd,SAA+BF,IAC/B,sBAAKE,WAAW,eAAhB,UAAgCJ,EAAhC,cAKZH,EAAMc,UAAU,CACZC,GAAGC,IAAUC,OAAOC,WACpBjB,MAAMe,IAAUG,OAAOD,WACvBhB,KAAKc,IAAUC,OAAOC,WACtBf,OAAOa,IAAUC,OAAOC,WACxBN,MAAMI,IAAUI,QAAQJ,IAAUG,QAAQD,WAC1Cb,SAASW,IAAUG,OAAOD,WAC1BZ,OAAOU,IAAUG,OAAOD,YAEblB,QCsJAqB,G,kNA/CbC,MAAM,CACJC,WAAW,EACXC,OAAO,I,EASTC,U,sBAAW,8BAAAC,EAAA,sEAC4BC,IAAMC,IAAI,4DADtC,gBACUJ,EADV,EACFK,KAAMA,KAAML,OACnB,EAAKM,SAAS,CAACN,SAAQD,WAAU,IAFxB,2C,kEAQTQ,KAAKN,c,+BAGE,IAAD,EACoBM,KAAKT,MAAxBC,EADD,EACCA,UAAWC,EADZ,EACYA,OAClB,OACE,yBAASjB,WAAW,YAApB,SACCgB,EACG,qBAAKhB,WAAW,SAAhB,SACE,sBAAMA,WAAW,cAAjB,8BAGF,qBAAKA,WAAW,SAAhB,SAEIiB,EAAOb,KAAI,SAAAqB,GAAK,OACd,cAAC,EAAD,CAAsB/B,MAAO+B,EAAM/B,MAAOC,KAAM8B,EAAM9B,KAAMC,OAAQ6B,EAAM7B,OAAQC,OAAQ4B,EAAM5B,OAAQC,SAAU2B,EAAM3B,SAAUC,OAAQ0B,EAAMC,oBAApID,EAAMjB,e,GApChBmB,IAAMC,YChIxBC,IAASC,OACP,cAAC,IAAMC,WAAP,UACE,cAAC,EAAD,MAEFC,SAASC,eAAe,W","file":"static/js/main.1a2efe23.chunk.js","sourcesContent":["import React from \"react\";\r\nimport PropTypes from \"prop-types\";\r\nimport \"./Movie.css\";\r\n\r\nfunction Movie({title,year,rating,genres,synopsis,poster}){\r\n    return (\r\n        <div classsname=\"movie\">\r\n            <div classsname=\"movie_title_year\">\r\n                <h3 classsname=\"movie_title\">{title}</h3>\r\n                <h5 clssssname=\"movie_year\">{year}</h5>\r\n            </div>\r\n            <div classsname=\"movie_poster\">\r\n                <img src={poster} alt={title} title={title}></img>\r\n            </div>\r\n            <ul classsname=\"movie-geners\">\r\n                {genres.map((genre,index) => (\r\n                    <li key={index} classsname=\"movie-geners-gener\">{genre}</li>\r\n                ))}\r\n            </ul>\r\n            <p classsname=\"movie_summery\">{synopsis}</p>\r\n            <div classsname=\"movie-rating\">{rating}/10.0</div>\r\n        </div>\r\n    );\r\n}\r\n\r\nMovie.prototype={\r\n    id:PropTypes.number.isRequired,\r\n    title:PropTypes.string.isRequired,\r\n    year:PropTypes.number.isRequired,\r\n    rating:PropTypes.number.isRequired,\r\n    genre:PropTypes.arrayOf(PropTypes.string).isRequired,\r\n    synopsis:PropTypes.string.isRequired,\r\n    poster:PropTypes.string.isRequired,\r\n}\r\nexport default Movie;","\nimport React from \"react\";\nimport axios from \"axios\";\nimport Movie from \"./Movie\";\nimport \"./App.css\";\n\n//import PropTypes from \"prop-types\";\n//import Test from './test';\n\n/*\nfunction Food({name,num,rating}) {\n  console.log();\n  return <div>\n    <h2>I like {name}</h2>\n    <h3>It is {num}</h3>\n    <h4>{rating}/5.0</h4>\n    </div>\n}\n\nFood.propTypes={\n  name:PropTypes.string.isRequired,\n  num:PropTypes.string.isRequired,\n  rating:PropTypes.number.isRequired\n}\n\n//porpTypes를 통해서 react magic에서 가져오는 props들을 검사할 수 있다.\n//property의 존재의 유무, property의 type의 검사등 props를 검사하는 것이다.\n/*\n  1. terminal -> npm i prop-types (install)\n  2. import PropTypes from \"porp-types\";\n  3. render function.propTypes={\n    property:PropTypes.type.isRequired\n  }\n*/\n\n/*\nconst foodILike=[\n  {id:1,name:\"kimchi\",num:\"first\",rating:4.5},\n  {id:2,name:\"rameun\",num:\"second\",rating:3.7},\n  {id:3,name:\"kimbab\",num:\"third\",rating:3.1},\n  {id:4,name:\"drink\",num:\"fourth\",rating:2.8},\n  {id:5,name:\"dongasu\",num:\"fifth\",rating:2.4}\n]\n*/\n\n/*\n//function component를 사용하는 방법\nfunction App() {      //component == html을 반환하는 function\n  return (\n    <div className=\"App\">\n      <h1>hello</h1>\n      {foodILike.map(function(dish){\n        return <Food key={dish.id} name={dish.name} num={dish.num} rating={dish.rating}/>\n      })}\n    </div>\n  );\n}       //function App은 html 을 반환하는 function이다\n*/\n\n\n/*\n//function component를 사용하는 방법이 아닌 state를 사용하기 위해 App class 생성\nclass App extends React.Component{\n  state={\n     count:0\n  };\n  add=()=>{\n    console.log(\"add\");\n    this.setState(current => ({count: current.count+1}));\n  };\n  minus=()=>{\n    console.log(\"minus\");\n    this.setState(current => ({count: current.count-1}));\n  };\n  render (){\n    return ( \n    <div>\n      <h1>I am class component</h1>\n      <h2>The count: {this.state.count}</h2>\n      <button onClick={this.add}>ADD</button>\n      <button onClick={this.minus}>MINUS</button>\n    </div>\n    );\n  }\n}\n*/\n\n/*\nApp class는 React.Component클래스에서 상속받는다.\nApp class는 함수가 아님으로 return할수 없다. 하지만 React.Component에 render메서드를 사용해서\n멤버 메서드로 가져온다음 render안에서 return 함으로서 실행할 수 있다.\n*/\n\n/*\nfunction componemt 대신 class component를 사용하는 이유!!\n우리가 사용하는 데이터가 동적으로 변화할때(API, server에서 data를 가져오는 경우...)\n우리는 object인 state를 사용하여 data를 state안에 저장해서\ndata를 사용하고 관리한다.\n이때 우리는 class compnent를 사용함으로 클래스 문법에 맞게 사용해야한다.\n(Java의 클래스 문법을 생각하면 이해가 쉽다.)\n*/\n\n/*\n궁극적으로 class component를 사용하는 목적인 state에 담긴 data의 변화이다.\n그러면 어떻게 data를 변화(조작)할 수 있는가??\n단순히 class문법인 this.state.count를 사용한다라고 생각 할 수 있다.\n하지만 이러한 경우 react는 변화한 state의 data값을 render할 수 없다.\n즉 우리는 state의 data값을 변화시킨다음 그것을 다시 render함으로서 보여야하는데\n이때 state를 직접적으로 사용한다면 react는 render를 refresh하지 않음으로 data의 변화를\n보이지 않는다. 따라서 우리는 setState를 사용해서 state의 data를 변화해야 한다.\n이때 setState에서 data를 변화할때 this.state.count처럼 사용하는 것이 아닌 current를 \n사용해서 state에 종속적이지 않고 사용할 수 있다.\n*/\n\n/*\ncomponent life cycle\nclass component임으로 생성과 종료의 cycle을 가지고 있다. \n크게 3가지로서 Mounting-Update-Unmounting이다 \n\n1. Mounting\nconstructor()->>생성자\nrender()\ncomponentDidMount() ->> render()후 component가 render되었음을 알림\n\n2. Update\nUpdate의 원인은 사용자이다(ex. state의 변화...)\nrender()\ncomponentDidUpdate() ->> render()이후 Update가 완료되었을때 componentDidUpdate가 실행된다\n\n3. Unmounting\ncomponentWillUnmount() ->> component가 종료될때 실행된다(page refresh,page close...).\nc++에서 소멸자와 비슷한 개념이다.\n*/\n\n\nclass App extends React.Component{\n\n  state={\n    isLoading: true,   \n    movies:[]\n  };\n\n  /*\n  componentDidMount(){\n    setTimeout( () => { this.setState( { isLoading : false } ); },6000);   //setState을 작성할때 state에 반드시 default값을 작성하지 않아도 된다\n  };\n  */\n  \n  getMovies= async ()=>{\n    const {data:{data:{movies}}} = await axios.get(\"https://yts-proxy.now.sh/list_movies.json?sort_by=rating\");\n    this.setState({movies, isLoading:false});\n  }\n  //API에서 data를 가져온다. 이때 data를 모두 가져올때 까지 비동기로 지정하고 기다리게 해준다.\n  //이때 사용되는 것이 async & await이다.\n\n  componentDidMount(){\n    this.getMovies();\n  }\n\n  render(){\n    const {isLoading, movies}=this.state;\n    return (\n      <section classsname=\"container\">\n      {isLoading ? (\n          <div classsname=\"loader\">\n            <span classsname=\"loader-text\">Now Loading...</span>\n          </div>\n        ) : (\n          <div classsname=\"movies\">\n            {\n              movies.map(movie => (\n                <Movie key={movie.id} title={movie.title} year={movie.year} rating={movie.rating} genres={movie.genres} synopsis={movie.synopsis} poster={movie.medium_cover_image} />\n              ))\n            }\n          </div> )\n        }\n      </section>\n    );\n  }\n}\n\n\n\n\nexport default App;\n\n//line 10 ->> <Test />\n\n/*application안에 많은 component를 포함할수 있고 이러한 component안에 다 많은\ncomponent를 import 할수 있다\n*/\n\n/*\n<Food fav  =\"kimchi\" someting={true} apapapp={[\"hello\",1,2,3,4,false]}/>\n\nFood라는 component에 fav라는 이름의 property(prop)를 \"kimchi\"라는 value로 준것이다\nporp의 value값으로는 다양한 것을 줄 수 있다.\n또한 react magic은 이러한 props를 가져가는 약할을 한다.\nFood component로 정보를 보내고자 하면 react는 모든 props(속성)을 Food component의 argument로\nprops를 전달해준다.\n이떄 argument로 전달하는 props는 js의 event 또는 python의 self같은 형식이다.\n따라서 argument를 조작해서 개별 property를 가져올수도 있다.\nlike Food({fav}) 라면 porps중에서 fav property를 가져오는 뜻이다.(props.fav=={fav})\n*/\n\n\n/*\n{foodILike.map(function(dish){\n  return <Food key={dish.id} name={dish.name} num={dish.num}/>\n})}\n\nfoodILike list를 map메서드로 인자 하나씩 받아서 function(dish)에 넣어서 return 해주는 코드이다.\n이때 dish는 foodILike에 인자 하니씩 받음으로 dish에는 component가 2개가 존재한다.\n따라서 dish.*를 통해 각각의 component를 조작할 수 있고 이것으 Food함수를 return 해줌으로서\n위의 code처럼 property를 조작할 수 있게 한다.\n또한 react는 그리 똑똑하지 않아서 react 내부적으로 구분할 수 있게\nlist에 각각의 요소는 유일해야 한다. 따라서 id값 같은 것을 통해 유일한 key를 가질 수 있게 한다.\n*/\n","import React from 'react';\nimport ReactDOM from 'react-dom';\n\nimport App from './App';\n\n\n\nReactDOM.render(            //component를 사용하고자 할때 사용하는 compotnent의 형태이다\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n//react는 component를 사용해서 html처럼 작성하려는 경우에 필요하다\n//위와같은 js와 html의 조합을 jsx라 부른다\n/*\nreact application은 한번에 하나의 component만 rendering할 수 있다\n따라서 모든 것은 application에 들어가야 한다.\n*/"],"sourceRoot":""}